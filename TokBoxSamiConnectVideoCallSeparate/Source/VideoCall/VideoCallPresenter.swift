//
//  VideoCallPresenter.swift
//  Sami
//
//  Created Kencor Health on 30/01/19.
//  Copyright © 2019 Kencor Health. All rights reserved .
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit

class VideoCallPresenter: VideoCallPresenterProtocol, VideoCallInteractorOutputProtocol {
    
    private enum MessengerStatus {
        case connecting
        case connected
        case disconnected
    }
    
    weak private var view       : VideoCallViewProtocol?
    var interactor              : VideoCallInteractorInputProtocol?
    private let router          : VideoCallWireframeProtocol
    private var currentMessage  : String = ""
    private var status          : MessengerStatus = .disconnected {
        didSet {
        }
    }
    
    
    private var title           : String {
        get {
            if status == .connecting || status == .disconnected {
                return "connecting..."
            } else {
//                if SessionData.shared.clinicDetail != nil {
//                    return SessionData.shared.clinicDetail.name ?? "Clinic Chat".loc()
//                } else {
                    return "Clinic Chat"
//                }
            }
        }
    }
    
    init(interface: VideoCallViewProtocol, interactor: VideoCallInteractorInputProtocol?, router: VideoCallWireframeProtocol) {
        self.view = interface
        self.interactor = interactor
        self.router = router
    }
    
    deinit {
        print("Deinit \(self)")
    }
    
    /**
     * Asynchronously begins the session connect process. Some time later, we will
     * expect a delegate method to call us back with the results of this action.
     */
    func doConnect() {
        self.interactor?.doConnect()
    }
    
    
    func displayError(_ message: String) {
        view?.displayError(message)
    }
    
    func muteSpeakerTapped() {
        self.interactor?.muteSpeakerTapped()
    }
    
    func btnVideoOnOffTapped() {
        self.interactor?.subscribeToVideo()
    }
    
    func btnMuteMiceTapped() {
        interactor?.btnMuteMiceTapped()
    }
    func didUpdateBtnMuteMice(isSelected: Bool) {
        view?.updateMuteMiceButton(isSelected)
    }
    
    func changeCameraTapped() {
        interactor?.changeCameraTapped()
    }
    
    func updateChangeCamera(isSelected: Bool) {
        view?.updateChangeCamera(isSelected: isSelected)
    }
    
    func cleanupSubscriber() {
        self.interactor?.cleanupSubscriber()
    }
    
    func cleanupPublisher() {
        self.interactor?.cleanupPublisher()
    }
    
    func doPublish(publisherView: UIView,isAudioChannelOnly: Bool) {
        self.view?.doPublish(publisherView: publisherView, isAudioChannelOnly: isAudioChannelOnly)
    }
    
    func didDisConnectDismissView() {
        self.view?.dismissController()
    }
    
    func updateMuteSpeaker(isSelected: Bool) {
        view?.updateMuteSpeaker(isSelected: isSelected)
    }
    
    func updateButtonIcons(_ micButtonSelected: Bool, speakerButtonSelected: Bool, cameraChangeButtonSelected: Bool, videoOnOffSelected: Bool) {
        view?.updateButtonIcons(micButtonSelected, speakerButtonSelected: speakerButtonSelected, cameraChangeButtonSelected: cameraChangeButtonSelected, videoOnOffSelected: videoOnOffSelected)
    }
    
    // View -> Presenter
    /**
    * Sets up an instance of OTPublisher to use with this session. OTPubilsher
    * binds to the device camera and microphone, and will provide A/V streams
    * to the OpenTok session.
    */
    func doPublish() {
            
    }
    
    func endCall() {
        self.interactor?.endCall()
    }
    func subscriberDidConnect(subscriberView: UIView,isAudioChannelOnly:Bool) {
        view?.subscriberDidConnect(subscriberView: subscriberView,isAudioChannelOnly:isAudioChannelOnly)
    }
    
    func getButtonIcons() {
        interactor?.getButtonIcons()
    }
    func callEndedByThisSide() {
        self.interactor?.callEndedByThisSide()
    }
    
        
    func startChat() {

    }
    
    func screenWillAppear() {

    }
    
    func screenWillDisappear() {

    }
    
    func evaluateText(_ text: String) {
        currentMessage = text.trimmingCharacters(in: .whitespacesAndNewlines)

    }
    
    func didJoinRoom() {
    }
    
    func messengerIsAvailable(_ available: Bool) {
        if available {
            status = .connected
        } else {
            status = .connecting
        }
    }
    
}
