//
//  VideoCallInteractor.swift
//  Sami
//
//  Created Kencor Health on 30/01/19.
//  Copyright © 2019 Kencor Health. All rights reserved .
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import OpenTok

class VideoCallInteractor: NSObject, VideoCallInteractorInputProtocol {
    
    
    weak var presenter                      : VideoCallInteractorOutputProtocol?
    private var objVideoCallMessage         : VideoCallMessage!
    private var shouldCheckFirstMessage     : Bool = false
    private var kickedFromRoom              : Bool = true
    private var isJoining                   : Bool = false
    var strPatientStreamId                  = ""
    var error                               : OTError?
    
    var arrSubscriber                       = [OTSubscriber]()
    var currentConnectionId                 : String! = ""
    var arrCurrentActiveStreams             = [String]()
    var isPostVisitCalled                   = false
    
    lazy var session: OTSession = {
        let apiKey      = self.objVideoCallMessage.apiKey ?? ""
        let sessionId   = self.objVideoCallMessage.sessionId ?? ""
        return OTSession(apiKey: apiKey, sessionId: sessionId, delegate: self)!
    }()
    
    lazy var publisher: OTPublisher = {
        let settings = OTPublisherSettings()
        settings.name = UIDevice.current.name
        return OTPublisher(delegate: self, settings: settings)!
    }()
    
    init(objVideoCallMessage:VideoCallMessage) {
        super.init()
        self.objVideoCallMessage      = objVideoCallMessage
    }
    
    deinit {
        print("Deinit \(self)")
    }
    
    func doConnect() {
        var error: OTError?
        defer {
            processError(error)
        }
        let tokenID = self.objVideoCallMessage.token ?? ""
        session.connect(withToken: tokenID, error: &error)
    }
    
    fileprivate func processError(_ error: OTError?) {
        if let err = error {
            self.presenter?.displayError(err.localizedDescription)
        }
    }
    
    func btnMuteMiceTapped() {
        self.publisher.publishAudio = !self.publisher.publishAudio
        self.presenter?.didUpdateBtnMuteMice(isSelected: self.publisher.publishAudio)
    }
    
    func changeCameraTapped() {
        if self.publisher.cameraPosition == .front {
            self.publisher.cameraPosition = .back
        } else {
            self.publisher.cameraPosition = .front
        }
        self.presenter?.updateChangeCamera(isSelected: (self.publisher.cameraPosition == .back))
    }
    
    func muteSpeakerTapped() {
        self.arrSubscriber.first?.subscribeToAudio = !(self.arrSubscriber.first?.subscribeToAudio ?? true)
        self.presenter?.updateMuteSpeaker(isSelected: self.arrSubscriber.first?.subscribeToAudio ?? true)
    }
    
    func subscribeToVideo() {
        self.publisher.publishVideo = !self.publisher.publishVideo
        self.updateButtonIcons()
    }
    
    
    func cleanupSubscriber() {
        for subscriber in arrSubscriber {
            subscriber.view?.removeFromSuperview()
        }
        self.arrSubscriber.removeAll()
    }
    
    func cleanupPublisher() {
        publisher.view?.removeFromSuperview()
    }
    
    func updateButtonIcons() {
        self.presenter?.updateButtonIcons(self.publisher.publishAudio, speakerButtonSelected: true, cameraChangeButtonSelected: (self.publisher.cameraPosition == .back), videoOnOffSelected: self.publisher.publishVideo)
    }
    
    
    func doPublish() {
        var error: OTError?
        defer {
            processError(error)
        }
        
        session.publish(publisher, error: &error)
        
        if let pubView = publisher.view {
            let isAudioOnly = publisher.stream?.hasVideo == false
            self.presenter?.doPublish(publisherView: pubView, isAudioChannelOnly: isAudioOnly)
            self.presenter?.updateButtonIcons(self.publisher.publishAudio, speakerButtonSelected: true, cameraChangeButtonSelected: (self.publisher.cameraPosition == .back), videoOnOffSelected: self.publisher.publishVideo)
            
        }
    }
    
    
    func getButtonIcons() {
        self.presenter?.updateButtonIcons(self.publisher.publishAudio, speakerButtonSelected: true, cameraChangeButtonSelected: (self.publisher.cameraPosition == .back), videoOnOffSelected: self.publisher.publishVideo)
    }
    
    
    
    
}


// MARK: - OTSession delegate callbacks
extension VideoCallInteractor: OTSessionDelegate {
    
    
    /**
     * Instantiates a subscriber for the given stream and asynchronously begins the
     * process to begin receiving A/V content for this stream. Unlike doPublish,
     * this method does not add the subscriber to the view hierarchy. Instead, we
     * add the subscriber only after it has connected and begins receiving data.
     */
    fileprivate func doSubscribe(_ stream: OTStream) {
        var error: OTError?
        defer {
            processError(error)
        }
        if let subscriber = OTSubscriber(stream: stream, delegate: self) {
            session.subscribe(subscriber, error: &error)
            self.arrSubscriber.append(subscriber)
        }
    }
    
    
    func sessionDidConnect(_ session: OTSession) {
        print("Session connected")
        
        if let con_id = session.connection?.connectionId {
            self.currentConnectionId = con_id
            self.callConnectionIdSendToServer(connectionID: con_id, isStart: true)
        }
        self.doPublish()
    }
    
    func sessionDidDisconnect(_ session: OTSession) {
        print("Session disconnected")
        if let con_id = session.connection?.connectionId {
            self.currentConnectionId = con_id
        }
        self.presenter?.didDisConnectDismissView()
    }
    
    func session(_ session: OTSession, streamCreated stream: OTStream) {
        print("Session streamCreated: \(stream.streamId)")
        
        if self.arrCurrentActiveStreams.count == 0 {
            self.strPatientStreamId = stream.streamId
        }
        
        if self.arrCurrentActiveStreams.count >= 2 {
            if stream.hasVideo == false {
                if self.arrCurrentActiveStreams.contains(stream.streamId) {
                    return
                } else {
                    self.arrCurrentActiveStreams.append(stream.streamId)
                    self.doSubscribe(stream)
                    return
                }
            } else {
                return
            }
        } else {
            if self.arrCurrentActiveStreams.contains(stream.streamId) {
                return
            } else {
                self.arrCurrentActiveStreams.append(stream.streamId)
                self.doSubscribe(stream)
            }
        }
        
    }
    
    func session(_ session: OTSession, streamDestroyed stream: OTStream) {
        print("Session streamDestroyed: \(stream.streamId)")
        
        if self.arrCurrentActiveStreams.contains(stream.streamId) {
            
//            if self.strPatientStreamId == stream.streamId {
//                if self.arrCurrentActiveStreams.count == 3 {
//                    let subscriber = self.findSubscriber(byStreamId: stream.streamId)
//                    if let subStream = subscriber?.stream, subStream.streamId == stream.streamId {
//                        subscriber?.view?.removeFromSuperview()
//                        if let s = subscriber {
//                            self.arrCurrentActiveStreams.removeObject(stream.streamId)
//                            self.arrSubscriber.removeObject(s)
//                        }
//                        return
//                    }
//                }
//            }
            
            if self.arrCurrentActiveStreams.count == 2 || self.arrCurrentActiveStreams.count == 3 {
                if stream.streamId == self.arrCurrentActiveStreams.last {
                    let subscriber = self.findSubscriber(byStreamId: stream.streamId)
                    if let subStream = subscriber?.stream, subStream.streamId == stream.streamId {
                        if let subscriber = subscriber {
                            subscriber.view?.removeFromSuperview()
                            self.arrCurrentActiveStreams.removeObject(stream.streamId)
                            self.arrSubscriber.removeObject(subscriber)
                        }
                        return
                    }
                }
            }
            
            print("out of return")
            let subscriber = self.findSubscriber(byStreamId: stream.streamId)
            if let subStream = subscriber?.stream, subStream.streamId == stream.streamId {
                cleanupSubscriber()
            }
            self.presenter?.didDisConnectDismissView()
        }
        
    }
    
    func session(_ session: OTSession, didFailWithError error: OTError) {
        print("session Failed to connect: \(error.localizedDescription)")
    }
    
    func findSubscriber(byStreamId id: String) -> (OTSubscriber)? {
        for (_, entry) in self.arrSubscriber.enumerated() {
            if let stream = entry.stream, stream.streamId == id {
                return entry
            }
        }
        return nil
    }
    
    
}



// MARK: - OTPublisher delegate callbacks
extension VideoCallInteractor: OTPublisherDelegate {
    func publisher(_ publisher: OTPublisherKit, streamCreated stream: OTStream) {
        print("Publishing")
    }
    
    func publisher(_ publisher: OTPublisherKit, streamDestroyed stream: OTStream) {
        
        if self.arrCurrentActiveStreams.count == 2 || self.arrCurrentActiveStreams.count == 3 {
            if stream.streamId == self.arrCurrentActiveStreams.last {
                let subscriber = self.findSubscriber(byStreamId: stream.streamId)
                if let subStream = subscriber?.stream, subStream.streamId == stream.streamId {
                    subscriber?.view?.removeFromSuperview()
                    if let s = subscriber {
                        self.arrSubscriber.removeObject(s)
                    }
                    return
                }
            }
        }
        
        cleanupPublisher()
        let subscriber = self.findSubscriber(byStreamId: stream.streamId)
        if let subStream = subscriber?.stream, subStream.streamId == stream.streamId {
            cleanupSubscriber()
        }
    }
    
    func publisher(_ publisher: OTPublisherKit, didFailWithError error: OTError) {
        print("Publisher failed: \(error.localizedDescription)")
    }
}

// MARK: - OTSubscriber delegate callbacks
extension VideoCallInteractor: OTSubscriberDelegate {
    func subscriberDidConnect(toStream subscriberKit: OTSubscriberKit) {
        if let subscriber = self.arrSubscriber.last {
            var isAudioChannelOnly = subscriber.stream?.hasVideo == false
            if let v = subscriber.view {
                self.presenter?.subscriberDidConnect(subscriberView: v, isAudioChannelOnly: isAudioChannelOnly)
            }
        }
    }
    
    func subscriber(_ subscriber: OTSubscriberKit, didFailWithError error: OTError) {
        print("Subscriber failed: \(error.localizedDescription)")
    }
    
    
    func endCall() {
        self.session.disconnect(&self.error)
        if isPostVisitCalled == false {
            self.isPostVisitCalled = true
            Timer.after(0.5) {
//                SamiChatOrchestrator.shared.askBubbleForPostVisit()
            }
        }
    }
    
    func subscriberDidDisconnect(fromStream subscriber: OTSubscriberKit) {
        print("subscriberDidDisconnect")
    }
}

extension VideoCallInteractor {
    
    func callEndedByThisSide() {
        self.callConnectionIdSendToServer(connectionID: self.currentConnectionId, isStart: false)
    }
    
    func callConnectionIdSendToServer(connectionID:String, isStart:Bool) {
//        var params = [String:Any]()
//        if isStart {
//            params = ["connectionId":connectionID]
//        }
//        _ = SamiApiService.videoConnectionStartEnd(isStart: isStart, params: params).subscribe(onNext: { (intValue) in
//        }, onError: { (err) in
//            print(err)
//        }, onCompleted: {
//
//        }, onDisposed: nil)
    }
    
}
